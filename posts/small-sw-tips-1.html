<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/0d132565a6ef74ad.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-07206ff3622cc1e4.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-735d320b4b8745cb.js" async="" crossorigin=""></script><script src="/_next/static/chunks/938-cd2116519108597b.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-0b5dd7ac61849cc9.js" async="" crossorigin=""></script><script src="/_next/static/chunks/250-e6a6f086b85a6178.js" async=""></script><script src="/_next/static/chunks/app/page-5ef23bef5d49f6f4.js" async=""></script><title>Small software tips, part 1</title><meta name="description" content="Notes of an armchair roboticist"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body><article class="post"><h1>Small software tips, part 1</h1><p>2024-08-09</p><div><p>Some small software tips, with a bias towards python and robotics. They are
mostly style suggestions for maintainability of code, and not solutions to
problems. These are collected from personal experience, but I don't take credit
for them. I learned by working with engineers better than myself. When I need an
example application, I will consider software for an aerial drone that performs
deliveries.</p>
<h1>Contents</h1>
<ul>
<li><a href="#saving-indents">Saving indents</a></li>
<li><a href="#import-statements"><code>import</code> statements</a></li>
<li><a href="#if-blocks"><code>if</code> blocks</a></li>
<li><a href="#return-statements"><code>return</code> statements</a></li>
<li><a href="#using-none">Using <code>None</code></a></li>
<li><a href="#avoid-unnecessary-variables">Avoid unnecessary variables</a></li>
<li><a href="#naming">Naming</a></li>
<li><a href="#standalone-functions">Standalone functions</a></li>
</ul>
<h1>Saving indents</h1>
<p>I like to reduce indent levels where possible. Code that is deeply indented
might be an opportunity to refactor and simplify. It is hard to read and keep
track of scope in such code, and I have found editing such code to be more
error-prone.</p>
<pre><code>def function():
    while condition:
        with resource:
            if predicate:
                # already at 4 levels of indent
</code></pre>
<p>Many other tips involve saving indents in some way.</p>
<h1><code>import</code> statements</h1>
<p>Ideally all <code>import</code>s appear at the top of a file. A way to group modules is:
standard library, external, internal.</p>
<pre><code>import datetime
import itertools

import numpy

import data_types
import perception
import analysis
</code></pre>
<p>The <code>import</code>s can be further ordered, say alphabetically, or based on
dependency. The last three <code>import</code>s above are from our hypothetical robotics
project, and presumably the <code>data_types</code> module is used by <code>perception</code>,
whose output is used in <code>analysis</code>.</p>
<p>All imports from a module should appear in a single line. So instead of</p>
<pre><code>from perception.detectors import ObjectDetector
...
from perception.detectors import detect_edges
</code></pre>
<p>prefer</p>
<pre><code>from perception.detectors import ObjectDetector, detect_edges
</code></pre>
<p>It's good to preserve logical dependency across project modules. For example, we
might add a function <code>calculate_area</code> to our <code>analysis</code> module, which another
engineer might then want to use in <code>perception</code>. Importing <code>analysis</code> code into
<code>perception</code> might work, but it would go against the dependency order stated
earlier, and possibly introduce a circular <code>import</code> situation. Instead, we can
move <code>calculate_area</code> to <code>perception</code>, or to another module that both depend on,
like <code>perception_helpers</code> (sounds silly here but might not in a large
codebase). A fallback is to <code>import analysis</code> in <code>perception</code>, but in local
scope, which can get around a circular dependency.</p>
<pre><code># in a file in perception/

def find_landing_zone():
    from analysis import calculate_area
</code></pre>
<h1><code>if</code> blocks</h1>
<p>In a function, an <code>if</code> block that returns (or otherwise exits by raising an
error) doesn't need to be followed by an <code>else</code> block. So instead of</p>
<pre><code>def function():
    if condition:
        # do work
        return
    else:
        # do other work
</code></pre>
<p>prefer</p>
<pre><code>def function():
    if condition:
        # do work
        return

    # do other work
</code></pre>
<p>Rather than a bunch of nested <code>if</code> statements, I prefer an <code>if</code>-ladder, which is
closer to a <code>switch</code>, such as</p>
<pre><code>if condn1:
    return value1
if condn2:
    return value2
...

return fallback_value
</code></pre>
<p>which is easier to debug and test. Due to the structure, only one block (the
first matching condition) can be hit, and we know that all previous conditions
evaluated to <code>False</code>. As an example, suppose our drone has two vision sensors, a
lidar generating point clouds, and a stereo camera. When finding a landing zone,
we need to check if the data is recent, and prefer using the point cloud if it
is of good quality. A hard to read version is</p>
<pre><code>def find_landing_zone():
    """ 
    :return: True if landing zone detected
    """
    if not data_stale():
        if point_cloud_good():
            if find_landing_zone_in_point_cloud():
                return True
            else:
                if find_landing_zone_in_stereo():
                    return True
                else:
                    return False
        else:
            if find_landing_zone_in_stereo():
                return True
            else:
                return False
    else:
        return False
</code></pre>
<p>which is the same as a flatter version.</p>
<pre><code>def find_landing_zone():
    """ 
    :return: True if landing zone detected
    """
    if data_stale():
        return False
    if point_cloud_good() and find_landing_zone_in_point_cloud():
        return True
    if find_landing_zone_in_stereo():
        return True
    return False
</code></pre>
<h1><code>return</code> statements</h1>
<p>Returning early from a function is a simple way to save indents and improve
readability. So instead of</p>
<pre><code>def function():
    if condition:
        # lots of work
</code></pre>
<p>prefer</p>
<pre><code>def function():
    if not condition:
       return

    # reduced indent level for lots of work
</code></pre>
<p>Avoid using tuples to return multiple values. It is a pattern that is hard to
extend. As an example, suppose <code>find_landing_zone</code> currently returns a tuple,</p>
<pre><code>def find_landing_zone():
    """
    :return: whether landing zone found, area
    :rtype: (bool, float)
    """
</code></pre>
<p>and we want to add a measure of planarity.</p>
<pre><code>def find_landing_zone():
    """
    :return: whether landing zone found, area, planarity
    :rtype: (bool, float, float)
    """
</code></pre>
<p>Then every <code>return</code> in the function has to be updated. This includes knowing
what to use as a null/ undefined value, say <code>(False, 0, None)</code>. If any calling
code unpacks the return,</p>
<pre><code>landing_zone_found, area = find_landing_zone()
</code></pre>
<p>it needs to be updated as well, otherwise it may lead to an error like
<code>ValueError: too many values to unpack ...</code>. An alternative is to return a
<code>dataclass</code>.</p>
<pre><code>from dataclasses import dataclass
from typing import Optional

@dataclass
class LandingZone:
      area: float = 0
      planarity: Optional[float] = None

def find_landing_zone():
    """
    :return: landing zone, if found
    :rtype: Optional[LandingZone]
    """
</code></pre>
<p>New fields can be added to <code>LandingZone</code> along with a default value, and
<code>return</code> statements that don't have a planarity will not need an update. A nit
is that I changed the convention of indicating that no landing zone was
found. Earlier, it was by returning <code>False</code> as the first tuple element, now it
is by returning <code>None</code>.</p>
<h1>Using <code>None</code></h1>
<p>It is nice to use a clear default value for an argument, like</p>
<pre><code>def algorithm(threshold=0.5):
    pass
</code></pre>
<p>but there are situations where using <code>None</code> as the default value of an argument
helps. Suppose the drone executes a <code>Trajectory</code></p>
<pre><code>class Trajectory:
    def __init__(self, waypoints=[]):
        self.waypoints = waypoints
</code></pre>
<p>and that <code>waypoints</code> can be appended to as the drone is moving along the
trajectory. The empty-list default value is mutable, and can lead to bugs.</p>
<pre><code>>>> traj1 = Trajectory()
>>> traj1.waypoints.append(0.1)
>>> traj1.waypoints.append(0.2)
>>> traj2 = Trajectory()
>>> traj2.waypoints
[0.1, 0.2]
</code></pre>
<p>An fix is to use a default value of <code>None</code>.</p>
<pre><code>class Trajectory:
    def __init__(self, waypoints=None):
        self.waypoints = waypoints or []
</code></pre>
<p>Another use is if an argument has to be passed down through many function
calls. Suppose we add an optional threshold called <code>minimum_landing_area</code> with
a default value of <code>1.5</code>. This requires making sure the default value is the
same everywhere, which is hard to maintain.</p>
<pre><code>perform_mission(*args, minimum_landing_area=1.5, **kwargs)
reach_address(*args, minimum_landing_area=1.5, **kwargs)
find_landing_zone(minimum_landing_area=1.5)
</code></pre>
<p>An alternative is to use a default value of <code>None</code></p>
<pre><code>perform_mission(*args, minimum_landing_area=None, **kwargs)
reach_address(*args, minimum_landing_area=None, **kwargs)
find_landing_zone(minimum_landing_area=None)
</code></pre>
<p>and then apply the default threshold in <code>find_landing_zone</code>.</p>
<pre><code>def find_landing_zone(minimum_landing_area=None):
    if minimum_landing_area is None:
        minimum_landing_area = 1.5
</code></pre>
<p>Avoid overloading the use of <code>None</code> as a return value. For example, the function
<code>find_landing_zone</code> may return <code>None</code> on failure to find a suitable
location. There may be many reasons: perception data is stale, corrupt, or there
is genuinely no location. If the calling code needs to know which of these
situations occurred, instead of returning <code>None</code>, we are better off explicitly
communicating this information (as a return code or exception).</p>
<p>In customizable software, many components are optional, and their absence is
often indicated by <code>None</code>. The price paid is that we have to check for
<code>None</code>-ness, a sort of disciplined flexibility. For example, the same drone
software might have to run on multiple generations of hardware:</p>
<ul>
<li>prototype robots with no perception,</li>
<li>robots with perception but no stereo camera,</li>
<li>robots with newer stereo cameras that calculate surface normals natively.</li>
</ul>
<p>If we want to make use of <code>perception.stereo_camera.surface_normals</code>, we have to
account for every field being <code>None</code>. Such <code>None</code> checks are best handled by a
few well-tested helper functions.</p>
<p>Another situation in which to check for <code>None</code> is state variables that may be
set only after instantiation. For example, perception might passively subscribe
to some <code>sensor_data</code></p>
<pre><code>class Perception:
    def __init__(self):
        self.sensor_data = None

    def receive_sensor_data(self, sensor_data):
        self.sensor_data = sensor_data
</code></pre>
<p>and <code>None</code> indicates that no data has been received yet. When there are multiple
such state variables, a better approach is to use an explicit flag indicating
that state has been initialized.</p>
<h1>Avoid unnecessary variables</h1>
<p>If a variable is created only to be passed as an argument (to a function or
constructor)</p>
<pre><code>def find_landing_zone():
    polygon = create_polygon(edges)
    area = calculate_area(polygon)
</code></pre>
<p>prefer</p>
<pre><code>def find_landing_zone():
    area = calculate_area(polygon=create_polygon(edges))
</code></pre>
<p>For readability, use keyword arguments and proper formatting (a linter helps).</p>
<p>When calling a function that returns a tuple, avoid naming unused return
variables. For readability, a comment can be added explaining why they are
unused.</p>
<pre><code>def execute_docking():
    # At this point in the function, we know the drone is
    # above a platform, so finding a landing zone is just a sanity check,
    # and we ignore the area detected.
    landing_zone_found, _ = find_landing_zone()
</code></pre>
<p>Avoid duplicate variables that store the same value. Suppose the system works by
receiving an order with the address for the drone to go to.</p>
<pre><code>@dataclass
class Order:
    address: str
</code></pre>
<p>A <code>Mission</code> object is created for each order. The mission needs the address, but
instead of copying it into an instance variable</p>
<pre><code>class Mission:
    def __init__(self, order):
        self.address = order.address
</code></pre>
<p>prefer storing the order itself. For convenient access, a <code>property</code> can be added to <code>Mission</code>.</p>
<pre><code>class Mission:
    def __init__(self, order):
        self.order = order

    @property
    def address(self):
        return self.order.address
</code></pre>
<p>A duplicate variable is an opportunity for introducing error. There might be
code that has access to both the <code>order</code> and <code>mission</code> objects, and now there is
no chance of a discrepancy between <code>order.address</code> and <code>mission.address</code>. When
storing references, however, something to watch for is memory leaks.</p>
<h1>Naming</h1>
<p>Choosing good names is important because renaming is hard. Names find a place
not only in code but also in people's heads. I once erred on the side of being
too descriptive with a name,
e.g. <code>landing_zone_minimum_area_perimeter_ratio_threshold</code>. When it became clear
that it was cumbersome and needed a refactor, edits were required in multiple
locations:</p>
<ul>
<li>the algorithm that made use of the threshold,</li>
<li>calling code such as mission software,</li>
<li>a message definition,</li>
<li>a database field.</li>
</ul>
<p>Avoid including implementation details in variable names, such as
<code>landing_zones_list</code>, instead preferring <code>landing_zones</code>. An implementation may
change.</p>
<p>Remove redundant tokens from names. If each robot has a unique identifier, it
can be stored as <code>robot.uid</code>, instead of <code>robot.robot_uid</code>.</p>
<p>When adding a new feature, resist the temptation to choose generic
names. If an engineer writes software to detect potential collisions to
stay away from, prefer <code>CollisionRegionDetection</code> to <code>SceneUnderstanding</code>. The
latter makes it sound like the feature solves all problems. I've seen classes
that do something very specific named a generic <code>Action</code> or <code>State</code>. Namespaces
help in this regard to contain names.</p>
<p>Avoid playing telephone with the name of a field that travels across
software. Consider a field like the <code>address</code> that a drone must travel to to. It could
have a path like:</p>
<ul>
<li>input by a user,</li>
<li>serialized to a message, which is received by drone mission software,</li>
<li>converted from the message to an internal data type,</li>
<li>recorded to a database.</li>
</ul>
<p>It seems harmless to substitute <code>address</code> with a synonym like <code>destination</code> at
some stage, or abbreviate to <code>addr</code>, but it is best to keep using <code>address</code>. If
the name has to be changed (because it is already in use), it can be done by a
helper function, and unit tested.</p>
<p>Unrelated to naming, but a similar tip is to avoid mangling the order of
arguments when calling a constructor or function, and use the order in the
definition.</p>
<h1>Standalone functions</h1>
<p>I like to keep in mind three scenarios of calling a function.</p>
<ul>
<li>In live software. This is the most important use case. The function has to be
correct and fast. It should log enough data to allow debugging.</li>
<li>In unit tests. It should be possible to mock inputs without too much effort.</li>
<li>On recorded data. Being able to replay the function is great for
debugging. Extra logs in the function can be enabled at this stage for insight
into what went on. If the function is fast enough to run on a dataset,
parameters can be tuned for better performance.</li>
</ul>
<p>I prefer standalone functions over instance methods for satisfying these
scenarios. Instance methods have easy access to object state, but for this same
reason, they can be harder to stand up in unit tests. This is especially true
for objects with heavy state, like a high-level mission class.</p>
<p>Python's first-class support for functions means that we can write flexible
software with standalone functions. A tip therefore is to pull out instance
methods and convert them to standalone functions if possible.</p>
<p>Similarly, avoid defining large functions inside another function. I have found
that these can be sloppily implemented. Moving the nested function out to where
it is clearly visible forces a cleaner implementation and better documentation.</p>
</div></article><footer><a href="/">Home</a></footer><script src="/_next/static/chunks/webpack-07206ff3622cc1e4.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/0d132565a6ef74ad.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:I[7690,[],\"\"]\n6:I[5613,[],\"\"]\n8:I[1778,[],\"\"]\n9:I[5250,[\"250\",\"static/chunks/250-e6a6f086b85a6178.js\",\"931\",\"static/chunks/app/page-5ef23bef5d49f6f4.js\"],\"\"]\nb:I[8955,[],\"\"]\n7:[\"slug\",\"small-sw-tips-1\",\"d\"]\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0d132565a6ef74ad.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"3QaHMm55SIjk_hJY0H6Bb\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/posts/small-sw-tips-1\",\"initialTree\":[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"small-sw-tips-1\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"small-sw-tips-1\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"small-sw-tips-1\",\"d\"],{\"children\":[\"__PAGE__\",{},[\"$L4\",\"$L5\",null]]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\",\"$7\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"children\":[[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":null}],[\"$\",\"footer\",null,{\"children\":[\"$\",\"$L9\",null,{\"href\":\"/\",\"children\":\"Home\"}]}]]}]}],null]],\"initialHead\":[false,\"$La\"],\"globalErrorComponent\":\"$b\"}]]\n"])</script><script>self.__next_f.push([1,"c:T41d9,"])</script><script>self.__next_f.push([1,"\u003cp\u003eSome small software tips, with a bias towards python and robotics. They are\nmostly style suggestions for maintainability of code, and not solutions to\nproblems. These are collected from personal experience, but I don't take credit\nfor them. I learned by working with engineers better than myself. When I need an\nexample application, I will consider software for an aerial drone that performs\ndeliveries.\u003c/p\u003e\n\u003ch1\u003eContents\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#saving-indents\"\u003eSaving indents\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#import-statements\"\u003e\u003ccode\u003eimport\u003c/code\u003e statements\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#if-blocks\"\u003e\u003ccode\u003eif\u003c/code\u003e blocks\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#return-statements\"\u003e\u003ccode\u003ereturn\u003c/code\u003e statements\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#using-none\"\u003eUsing \u003ccode\u003eNone\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#avoid-unnecessary-variables\"\u003eAvoid unnecessary variables\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#naming\"\u003eNaming\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#standalone-functions\"\u003eStandalone functions\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eSaving indents\u003c/h1\u003e\n\u003cp\u003eI like to reduce indent levels where possible. Code that is deeply indented\nmight be an opportunity to refactor and simplify. It is hard to read and keep\ntrack of scope in such code, and I have found editing such code to be more\nerror-prone.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edef function():\n    while condition:\n        with resource:\n            if predicate:\n                # already at 4 levels of indent\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMany other tips involve saving indents in some way.\u003c/p\u003e\n\u003ch1\u003e\u003ccode\u003eimport\u003c/code\u003e statements\u003c/h1\u003e\n\u003cp\u003eIdeally all \u003ccode\u003eimport\u003c/code\u003es appear at the top of a file. A way to group modules is:\nstandard library, external, internal.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport datetime\nimport itertools\n\nimport numpy\n\nimport data_types\nimport perception\nimport analysis\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eimport\u003c/code\u003es can be further ordered, say alphabetically, or based on\ndependency. The last three \u003ccode\u003eimport\u003c/code\u003es above are from our hypothetical robotics\nproject, and presumably the \u003ccode\u003edata_types\u003c/code\u003e module is used by \u003ccode\u003eperception\u003c/code\u003e,\nwhose output is used in \u003ccode\u003eanalysis\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAll imports from a module should appear in a single line. So instead of\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efrom perception.detectors import ObjectDetector\n...\nfrom perception.detectors import detect_edges\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eprefer\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efrom perception.detectors import ObjectDetector, detect_edges\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt's good to preserve logical dependency across project modules. For example, we\nmight add a function \u003ccode\u003ecalculate_area\u003c/code\u003e to our \u003ccode\u003eanalysis\u003c/code\u003e module, which another\nengineer might then want to use in \u003ccode\u003eperception\u003c/code\u003e. Importing \u003ccode\u003eanalysis\u003c/code\u003e code into\n\u003ccode\u003eperception\u003c/code\u003e might work, but it would go against the dependency order stated\nearlier, and possibly introduce a circular \u003ccode\u003eimport\u003c/code\u003e situation. Instead, we can\nmove \u003ccode\u003ecalculate_area\u003c/code\u003e to \u003ccode\u003eperception\u003c/code\u003e, or to another module that both depend on,\nlike \u003ccode\u003eperception_helpers\u003c/code\u003e (sounds silly here but might not in a large\ncodebase). A fallback is to \u003ccode\u003eimport analysis\u003c/code\u003e in \u003ccode\u003eperception\u003c/code\u003e, but in local\nscope, which can get around a circular dependency.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# in a file in perception/\n\ndef find_landing_zone():\n    from analysis import calculate_area\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e\u003ccode\u003eif\u003c/code\u003e blocks\u003c/h1\u003e\n\u003cp\u003eIn a function, an \u003ccode\u003eif\u003c/code\u003e block that returns (or otherwise exits by raising an\nerror) doesn't need to be followed by an \u003ccode\u003eelse\u003c/code\u003e block. So instead of\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edef function():\n    if condition:\n        # do work\n        return\n    else:\n        # do other work\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eprefer\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edef function():\n    if condition:\n        # do work\n        return\n\n    # do other work\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRather than a bunch of nested \u003ccode\u003eif\u003c/code\u003e statements, I prefer an \u003ccode\u003eif\u003c/code\u003e-ladder, which is\ncloser to a \u003ccode\u003eswitch\u003c/code\u003e, such as\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif condn1:\n    return value1\nif condn2:\n    return value2\n...\n\nreturn fallback_value\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhich is easier to debug and test. Due to the structure, only one block (the\nfirst matching condition) can be hit, and we know that all previous conditions\nevaluated to \u003ccode\u003eFalse\u003c/code\u003e. As an example, suppose our drone has two vision sensors, a\nlidar generating point clouds, and a stereo camera. When finding a landing zone,\nwe need to check if the data is recent, and prefer using the point cloud if it\nis of good quality. A hard to read version is\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edef find_landing_zone():\n    \"\"\" \n    :return: True if landing zone detected\n    \"\"\"\n    if not data_stale():\n        if point_cloud_good():\n            if find_landing_zone_in_point_cloud():\n                return True\n            else:\n                if find_landing_zone_in_stereo():\n                    return True\n                else:\n                    return False\n        else:\n            if find_landing_zone_in_stereo():\n                return True\n            else:\n                return False\n    else:\n        return False\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhich is the same as a flatter version.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edef find_landing_zone():\n    \"\"\" \n    :return: True if landing zone detected\n    \"\"\"\n    if data_stale():\n        return False\n    if point_cloud_good() and find_landing_zone_in_point_cloud():\n        return True\n    if find_landing_zone_in_stereo():\n        return True\n    return False\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e\u003ccode\u003ereturn\u003c/code\u003e statements\u003c/h1\u003e\n\u003cp\u003eReturning early from a function is a simple way to save indents and improve\nreadability. So instead of\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edef function():\n    if condition:\n        # lots of work\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eprefer\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edef function():\n    if not condition:\n       return\n\n    # reduced indent level for lots of work\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAvoid using tuples to return multiple values. It is a pattern that is hard to\nextend. As an example, suppose \u003ccode\u003efind_landing_zone\u003c/code\u003e currently returns a tuple,\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edef find_landing_zone():\n    \"\"\"\n    :return: whether landing zone found, area\n    :rtype: (bool, float)\n    \"\"\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand we want to add a measure of planarity.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edef find_landing_zone():\n    \"\"\"\n    :return: whether landing zone found, area, planarity\n    :rtype: (bool, float, float)\n    \"\"\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen every \u003ccode\u003ereturn\u003c/code\u003e in the function has to be updated. This includes knowing\nwhat to use as a null/ undefined value, say \u003ccode\u003e(False, 0, None)\u003c/code\u003e. If any calling\ncode unpacks the return,\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elanding_zone_found, area = find_landing_zone()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eit needs to be updated as well, otherwise it may lead to an error like\n\u003ccode\u003eValueError: too many values to unpack ...\u003c/code\u003e. An alternative is to return a\n\u003ccode\u003edataclass\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efrom dataclasses import dataclass\nfrom typing import Optional\n\n@dataclass\nclass LandingZone:\n      area: float = 0\n      planarity: Optional[float] = None\n\ndef find_landing_zone():\n    \"\"\"\n    :return: landing zone, if found\n    :rtype: Optional[LandingZone]\n    \"\"\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNew fields can be added to \u003ccode\u003eLandingZone\u003c/code\u003e along with a default value, and\n\u003ccode\u003ereturn\u003c/code\u003e statements that don't have a planarity will not need an update. A nit\nis that I changed the convention of indicating that no landing zone was\nfound. Earlier, it was by returning \u003ccode\u003eFalse\u003c/code\u003e as the first tuple element, now it\nis by returning \u003ccode\u003eNone\u003c/code\u003e.\u003c/p\u003e\n\u003ch1\u003eUsing \u003ccode\u003eNone\u003c/code\u003e\u003c/h1\u003e\n\u003cp\u003eIt is nice to use a clear default value for an argument, like\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edef algorithm(threshold=0.5):\n    pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ebut there are situations where using \u003ccode\u003eNone\u003c/code\u003e as the default value of an argument\nhelps. Suppose the drone executes a \u003ccode\u003eTrajectory\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass Trajectory:\n    def __init__(self, waypoints=[]):\n        self.waypoints = waypoints\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand that \u003ccode\u003ewaypoints\u003c/code\u003e can be appended to as the drone is moving along the\ntrajectory. The empty-list default value is mutable, and can lead to bugs.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003e\u003e\u003e traj1 = Trajectory()\n\u003e\u003e\u003e traj1.waypoints.append(0.1)\n\u003e\u003e\u003e traj1.waypoints.append(0.2)\n\u003e\u003e\u003e traj2 = Trajectory()\n\u003e\u003e\u003e traj2.waypoints\n[0.1, 0.2]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAn fix is to use a default value of \u003ccode\u003eNone\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass Trajectory:\n    def __init__(self, waypoints=None):\n        self.waypoints = waypoints or []\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnother use is if an argument has to be passed down through many function\ncalls. Suppose we add an optional threshold called \u003ccode\u003eminimum_landing_area\u003c/code\u003e with\na default value of \u003ccode\u003e1.5\u003c/code\u003e. This requires making sure the default value is the\nsame everywhere, which is hard to maintain.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eperform_mission(*args, minimum_landing_area=1.5, **kwargs)\nreach_address(*args, minimum_landing_area=1.5, **kwargs)\nfind_landing_zone(minimum_landing_area=1.5)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAn alternative is to use a default value of \u003ccode\u003eNone\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eperform_mission(*args, minimum_landing_area=None, **kwargs)\nreach_address(*args, minimum_landing_area=None, **kwargs)\nfind_landing_zone(minimum_landing_area=None)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand then apply the default threshold in \u003ccode\u003efind_landing_zone\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edef find_landing_zone(minimum_landing_area=None):\n    if minimum_landing_area is None:\n        minimum_landing_area = 1.5\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAvoid overloading the use of \u003ccode\u003eNone\u003c/code\u003e as a return value. For example, the function\n\u003ccode\u003efind_landing_zone\u003c/code\u003e may return \u003ccode\u003eNone\u003c/code\u003e on failure to find a suitable\nlocation. There may be many reasons: perception data is stale, corrupt, or there\nis genuinely no location. If the calling code needs to know which of these\nsituations occurred, instead of returning \u003ccode\u003eNone\u003c/code\u003e, we are better off explicitly\ncommunicating this information (as a return code or exception).\u003c/p\u003e\n\u003cp\u003eIn customizable software, many components are optional, and their absence is\noften indicated by \u003ccode\u003eNone\u003c/code\u003e. The price paid is that we have to check for\n\u003ccode\u003eNone\u003c/code\u003e-ness, a sort of disciplined flexibility. For example, the same drone\nsoftware might have to run on multiple generations of hardware:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eprototype robots with no perception,\u003c/li\u003e\n\u003cli\u003erobots with perception but no stereo camera,\u003c/li\u003e\n\u003cli\u003erobots with newer stereo cameras that calculate surface normals natively.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf we want to make use of \u003ccode\u003eperception.stereo_camera.surface_normals\u003c/code\u003e, we have to\naccount for every field being \u003ccode\u003eNone\u003c/code\u003e. Such \u003ccode\u003eNone\u003c/code\u003e checks are best handled by a\nfew well-tested helper functions.\u003c/p\u003e\n\u003cp\u003eAnother situation in which to check for \u003ccode\u003eNone\u003c/code\u003e is state variables that may be\nset only after instantiation. For example, perception might passively subscribe\nto some \u003ccode\u003esensor_data\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass Perception:\n    def __init__(self):\n        self.sensor_data = None\n\n    def receive_sensor_data(self, sensor_data):\n        self.sensor_data = sensor_data\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand \u003ccode\u003eNone\u003c/code\u003e indicates that no data has been received yet. When there are multiple\nsuch state variables, a better approach is to use an explicit flag indicating\nthat state has been initialized.\u003c/p\u003e\n\u003ch1\u003eAvoid unnecessary variables\u003c/h1\u003e\n\u003cp\u003eIf a variable is created only to be passed as an argument (to a function or\nconstructor)\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edef find_landing_zone():\n    polygon = create_polygon(edges)\n    area = calculate_area(polygon)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eprefer\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edef find_landing_zone():\n    area = calculate_area(polygon=create_polygon(edges))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor readability, use keyword arguments and proper formatting (a linter helps).\u003c/p\u003e\n\u003cp\u003eWhen calling a function that returns a tuple, avoid naming unused return\nvariables. For readability, a comment can be added explaining why they are\nunused.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edef execute_docking():\n    # At this point in the function, we know the drone is\n    # above a platform, so finding a landing zone is just a sanity check,\n    # and we ignore the area detected.\n    landing_zone_found, _ = find_landing_zone()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAvoid duplicate variables that store the same value. Suppose the system works by\nreceiving an order with the address for the drone to go to.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@dataclass\nclass Order:\n    address: str\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA \u003ccode\u003eMission\u003c/code\u003e object is created for each order. The mission needs the address, but\ninstead of copying it into an instance variable\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass Mission:\n    def __init__(self, order):\n        self.address = order.address\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eprefer storing the order itself. For convenient access, a \u003ccode\u003eproperty\u003c/code\u003e can be added to \u003ccode\u003eMission\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass Mission:\n    def __init__(self, order):\n        self.order = order\n\n    @property\n    def address(self):\n        return self.order.address\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA duplicate variable is an opportunity for introducing error. There might be\ncode that has access to both the \u003ccode\u003eorder\u003c/code\u003e and \u003ccode\u003emission\u003c/code\u003e objects, and now there is\nno chance of a discrepancy between \u003ccode\u003eorder.address\u003c/code\u003e and \u003ccode\u003emission.address\u003c/code\u003e. When\nstoring references, however, something to watch for is memory leaks.\u003c/p\u003e\n\u003ch1\u003eNaming\u003c/h1\u003e\n\u003cp\u003eChoosing good names is important because renaming is hard. Names find a place\nnot only in code but also in people's heads. I once erred on the side of being\ntoo descriptive with a name,\ne.g. \u003ccode\u003elanding_zone_minimum_area_perimeter_ratio_threshold\u003c/code\u003e. When it became clear\nthat it was cumbersome and needed a refactor, edits were required in multiple\nlocations:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ethe algorithm that made use of the threshold,\u003c/li\u003e\n\u003cli\u003ecalling code such as mission software,\u003c/li\u003e\n\u003cli\u003ea message definition,\u003c/li\u003e\n\u003cli\u003ea database field.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAvoid including implementation details in variable names, such as\n\u003ccode\u003elanding_zones_list\u003c/code\u003e, instead preferring \u003ccode\u003elanding_zones\u003c/code\u003e. An implementation may\nchange.\u003c/p\u003e\n\u003cp\u003eRemove redundant tokens from names. If each robot has a unique identifier, it\ncan be stored as \u003ccode\u003erobot.uid\u003c/code\u003e, instead of \u003ccode\u003erobot.robot_uid\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWhen adding a new feature, resist the temptation to choose generic\nnames. If an engineer writes software to detect potential collisions to\nstay away from, prefer \u003ccode\u003eCollisionRegionDetection\u003c/code\u003e to \u003ccode\u003eSceneUnderstanding\u003c/code\u003e. The\nlatter makes it sound like the feature solves all problems. I've seen classes\nthat do something very specific named a generic \u003ccode\u003eAction\u003c/code\u003e or \u003ccode\u003eState\u003c/code\u003e. Namespaces\nhelp in this regard to contain names.\u003c/p\u003e\n\u003cp\u003eAvoid playing telephone with the name of a field that travels across\nsoftware. Consider a field like the \u003ccode\u003eaddress\u003c/code\u003e that a drone must travel to to. It could\nhave a path like:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003einput by a user,\u003c/li\u003e\n\u003cli\u003eserialized to a message, which is received by drone mission software,\u003c/li\u003e\n\u003cli\u003econverted from the message to an internal data type,\u003c/li\u003e\n\u003cli\u003erecorded to a database.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIt seems harmless to substitute \u003ccode\u003eaddress\u003c/code\u003e with a synonym like \u003ccode\u003edestination\u003c/code\u003e at\nsome stage, or abbreviate to \u003ccode\u003eaddr\u003c/code\u003e, but it is best to keep using \u003ccode\u003eaddress\u003c/code\u003e. If\nthe name has to be changed (because it is already in use), it can be done by a\nhelper function, and unit tested.\u003c/p\u003e\n\u003cp\u003eUnrelated to naming, but a similar tip is to avoid mangling the order of\narguments when calling a constructor or function, and use the order in the\ndefinition.\u003c/p\u003e\n\u003ch1\u003eStandalone functions\u003c/h1\u003e\n\u003cp\u003eI like to keep in mind three scenarios of calling a function.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIn live software. This is the most important use case. The function has to be\ncorrect and fast. It should log enough data to allow debugging.\u003c/li\u003e\n\u003cli\u003eIn unit tests. It should be possible to mock inputs without too much effort.\u003c/li\u003e\n\u003cli\u003eOn recorded data. Being able to replay the function is great for\ndebugging. Extra logs in the function can be enabled at this stage for insight\ninto what went on. If the function is fast enough to run on a dataset,\nparameters can be tuned for better performance.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI prefer standalone functions over instance methods for satisfying these\nscenarios. Instance methods have easy access to object state, but for this same\nreason, they can be harder to stand up in unit tests. This is especially true\nfor objects with heavy state, like a high-level mission class.\u003c/p\u003e\n\u003cp\u003ePython's first-class support for functions means that we can write flexible\nsoftware with standalone functions. A tip therefore is to pull out instance\nmethods and convert them to standalone functions if possible.\u003c/p\u003e\n\u003cp\u003eSimilarly, avoid defining large functions inside another function. I have found\nthat these can be sloppily implemented. Moving the nested function out to where\nit is clearly visible forces a cleaner implementation and better documentation.\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"className\":\"post\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"Small software tips, part 1\"}],[\"$\",\"p\",null,{\"children\":\"2024-08-09\"}],[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]]}]\na:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Small software tips, part 1\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"Notes of an armchair roboticist\"}]]\n4:null\n"])</script><script>self.__next_f.push([1,""])</script></body></html>